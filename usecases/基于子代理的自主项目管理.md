# 基于子代理的自主项目管理

管理具有多个并行工作流的复杂项目非常累人。你最终会不断切换上下文,跨工具跟踪状态,并手动协调交接。

这个用例实现了一种去中心化的项目管理模式,其中子代理自主处理任务,通过共享状态文件而非中央协调器进行协调。

## 痛点

传统的协调器模式会造成瓶颈——主代理变成了交通警察。对于复杂项目(多仓库重构、研究冲刺、内容流水线),你需要能够在无需持续监督的情况下并行工作的代理。

## 功能介绍

- **去中心化协调**: 代理读写共享的`STATE.yaml`文件
- **并行执行**: 多个子代理同时处理独立任务
- **无协调器开销**: 主会话保持精简(CEO模式——仅负责战略)
- **自文档化**: 所有任务状态都保存在版本控制文件中

## 核心模式: STATE.yaml

每个项目都维护一个`STATE.yaml`文件,作为单一事实来源:

```yaml
# STATE.yaml - 项目协调文件
project: website-redesign
updated: 2026-02-10T14:30:00Z

tasks:
  - id: homepage-hero
    status: in_progress
    owner: pm-frontend
    started: 2026-02-10T12:00:00Z
    notes: "正在处理响应式布局"

  - id: api-auth
    status: done
    owner: pm-backend
    completed: 2026-02-10T14:00:00Z
    output: "src/api/auth.ts"

  - id: content-migration
    status: blocked
    owner: pm-content
    blocked_by: api-auth
    notes: "等待新的端点 schema"

next_actions:
  - "pm-content: 现在api-auth已完成,恢复迁移"
  - "pm-frontend: 与设计团队评审hero部分"
```

## 工作原理

1. **主代理接收任务** → 生成具有特定范围的子代理
2. **子代理读取STATE.yaml** → 找到分配给自己的任务
3. **子代理自主工作** → 更新STATE.yaml以反映进度
4. **其他代理轮询STATE.yaml** → 接手解除阻塞的工作
5. **主代理定期检查** → 查看状态,调整优先级

## 所需技能

- `sessions_spawn` / `sessions_send` 用于子代理管理
- 文件系统访问权限以操作STATE.yaml
- Git用于状态版本控制(可选但推荐)

## 设置: AGENTS.md配置

```text
## PM 委派模式

主会话 = 仅协调者。所有执行都交给子代理。

工作流:
1. 新任务到达
2. 检查PROJECT_REGISTRY.md中是否有现有PM
3. 如果PM存在 → sessions_send(label="pm-xxx", message="[任务]")
4. 如果是新项目 → sessions_spawn(label="pm-xxx", task="[任务]")
5. PM执行任务,更新STATE.yaml,报告结果
6. 主代理向用户总结

规则:
- 主会话: 最多0-2次工具调用(仅生成/发送)
- PM拥有自己的STATE.yaml文件
- PM可以为并行子任务生成子子代理
- 所有状态更改都提交到git
```

## 示例: 生成PM

```text
用户: "重构认证模块并更新文档"

主代理:
1. 检查注册表 → 没有活跃的pm-auth
2. 生成: sessions_spawn(
     label="pm-auth-refactor",
     task="重构认证模块,更新文档。在STATE.yaml中跟踪进度"
   )
3. 回复: "已生成pm-auth-refactor。完成后我会报告。"

PM子代理:
1. 创建包含任务分解的STATE.yaml
2. 处理任务,更新状态
3. 提交更改
4. 向主代理报告完成
```

## 关键见解

- **STATE.yaml > 协调器**: 基于文件的协调比消息传递扩展性更好
- **Git作为审计日志**: 提交STATE.yaml更改以保留完整历史
- **标签约定很重要**: 使用`pm-{project}-{scope}`以便于跟踪
- **精简主会话**: 主代理做得越少,响应速度越快

## 灵感来源

这种模式灵感来自[Nicholas Carlini的方法](https://nicholas.carlini.com/)来实现自主编码代理——让代理自我组织而非微观管理它们。

## 相关链接

- [OpenClaw子代理文档](https://github.com/openclaw/openclaw)
- [Anthropic: 构建高效代理](https://www.anthropic.com/research/building-effective-agents)